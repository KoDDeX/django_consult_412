# Урок 62: Магия Django Class-Based Views (CBV)

## Введение: Простота и мощь CBV

Class-Based Views (CBV) в Django представляют собой альтернативный способ написания представлений с использованием классов Python вместо функций (Function-Based Views, FBV). Они приносят с собой преимущества объектно-ориентированного программирования, такие как наследование и миксины, что позволяет писать более структурированный, переиспользуемый (DRY - Don't Repeat Yourself) и легко расширяемый код, особенно для стандартных задач CRUD (Create, Read, Update, Delete).

**Тезис:** "CBV — это элегантно и просто для типовых задач, но при этом невероятно гибко для сложных сценариев."

Мы начнем с самых основ, чтобы понять, как CBV работают "под капотом", а затем перейдем к более специализированным встроенным представлениям, которые Django любезно предоставляет для нас.

## Этап 1: Базовые CBV - `View` и `TemplateView`

### 1. `django.views.View` - Фундамент всего

**Коммит:** `lesson_62: feat: Реализован базовый View и обработка GET/POST запросов`

Класс `django.views.View` является родительским для всех представлений в Django, включая как встроенные generic CBV, так и те, что вы создаете сами. Он предоставляет базовую структуру для обработки HTTP-запросов.

**Как он обрабатывает запросы:**

1.  **`as_view()`**: Когда вы определяете URL-маршрут для CBV, вы используете метод класса `as_view()`. Этот метод создает экземпляр вашего класса View при каждом запросе и вызывает его метод `dispatch()`.
    ```python
    # urls.py
    from django.urls import path
    from .views import MyView

    urlpatterns = [
        path('my-view/', MyView.as_view(), name='my-view'),
    ]
    ```

2.  **`dispatch(request, *args, **kwargs)`**: Этот метод является "диспетчером". Он смотрит на HTTP-метод запроса (`request.method`, например, 'GET', 'POST', 'PUT' и т.д.) и пытается вызвать метод экземпляра класса, имя которого совпадает с именем HTTP-метода в нижнем регистре (например, `get()`, `post()`). Если такой метод не найден, вызывается `http_method_not_allowed()`.
    *   Именно `dispatch()` отвечает за то, чтобы правильный обработчик был вызван для правильного типа запроса.

3.  **Обработка HTTP-методов (`get()`, `post()`, etc.)**: Вы переопределяете эти методы в своем классе для реализации логики, специфичной для каждого HTTP-глагола. Каждый из этих методов должен возвращать объект `HttpResponse` (или его подкласс, например, `JsonResponse`, `HttpResponseRedirect`).
    ```python
    # views.py
    from django.http import HttpResponse
    from django.views import View

    class GreetingView(View):
        greeting_get = "Привет, мир! (GET)"
        greeting_post = "Вы отправили POST запрос!"

        def get(self, request, *args, **kwargs):
            # Логика для GET запроса
            return HttpResponse(self.greeting_get)

        def post(self, request, *args, **kwargs):
            # Логика для POST запроса
            return HttpResponse(self.greeting_post)
    ```

**Атрибут `http_method_names`:**

`View` имеет атрибут `http_method_names`, который по умолчанию содержит список разрешенных HTTP-методов: `['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'trace']`.
Если ваш View должен поддерживать только определенные методы (например, только `GET`), вы можете переопределить этот атрибут в своем классе:

```python
# views.py
from django.http import HttpResponse
from django.views import View

class ReadOnlyView(View):
    http_method_names = ['get', 'head', 'options'] # Разрешаем только эти методы

    def get(self, request, *args, **kwargs):
        return HttpResponse("Это представление только для чтения.")

    # Если придет POST запрос, будет возвращена ошибка 405 Method Not Allowed
```
Это полезно для явного указания, какие операции поддерживает ваше представление, и для безопасности, чтобы предотвратить нежелательные типы запросов.

**Когда использовать `View`?**
Хотя `View` является основой, напрямую от него наследуются не так часто, потому что Django предоставляет множество более специализированных generic CBV (`TemplateView`, `ListView`, `DetailView` и т.д.), которые уже реализуют большую часть типовой логики. Однако понимание работы `View` и `dispatch()` критически важно для понимания всех остальных CBV. Вы можете наследоваться от `View` напрямую, если вам нужна очень специфическая логика обработки запросов, которая не укладывается в рамки стандартных generic views.
